<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema 

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="textBox1.Text" xml:space="preserve">
    <value>Buttons:
     Draw –    Once a valid command has been entered, pressing this button will cause the command to be drawn on the canvas
     Syntax –  This button can be used to check the syntax of your command before you run it to make sure that it will run correctly.
     Clear –    This will clear the canvas and the input fields.
     Save –     This button can be used to save the current contents of the multi-line text box so that next time you use the studio, 
                    you can pick up from where you left off!
     Load –    This button can be used to load previously saved drawings

Text boxes:
     Single Line -   This is the input box just above the run, syntax, and clear buttons. This is used for executing one command at a time.
     Multi-line -     This is the input box bellow the save and load button. This is used to enter longer lists of commands that will be executed one 
                           after another, line after line.
     Output box -  This is the text box at the bottom. This is where any errors may be reported.

Drawing shapes:
The five shapes can all be used in similar ways. You can either just say the shape you want, and a preset sized version of that shape will be drawn at the last saved position. Or, you can say the shape and specify the size of the shape you'd like to draw, and a shape of that size will be drawn!
     Circle &lt;radius&gt; 
     Square &lt;side length&gt;
     Rectangle &lt;width&gt; &lt;height&gt;
     Triangle &lt;side length&gt;
     Polygon &lt;number of sizes&gt; &lt;side length&gt; - Optionally, you don’t need to specify the sides’ length 
     DrawTo &lt;x&gt; &lt;y&gt; - To draw a line, just specify where you want the line to end

Fill and Colour Options:
You don’t want to just be drawing in black and white, do you? You can change a few settings to be able to draw in a selection of colours, and also, decide if you want to draw in solid filled shapes or just their outlines using the following commands:
     Fill/On – Either of these words can be used to toggle the filled shapes be drawn
     Draw/Off – Either of these words can be used toggle the outlines shapes to be drawn 
     Pen &lt;colour&gt; - You can modify the pen colour by preceding the desired colour with the action word "Pen." 
                              This allows you to set the pen colour to one of the following options:
Black, Blue, Green, Orange, Pink, Purple, Red, Yellow, or White

Other Commands:
     Reset – Reset the art studio back to its beginning state
     MoveTo &lt;x&gt; &lt;y&gt; – Move the cursor for where to begin drawing from

Variables:
If you’d like to set values to the available variable names, you can build a command like the following:
     Var &lt;variable name&gt; &lt;variable int value&gt;
This will save the numerical value to the corresponding variable name. The following is a list of available variable names:
Count, Side, Height, Width, Radius

If Statements (Advanced):
When creating a multi-line program, you can add an “if condition” in your code. This looks like the following example:
     Count 30
     If count &lt; 20
     Pen blue
     Square
     Endif
With any if statement that you may chose to use, if the statement evaluates to be true, then the code within the if statement block will be executed, otherwise, it will be ignored. The if statement must be started with “if” and be ended with “endif”, but and variable name can be used and any of the three following operators can be used: “==”, “&lt;”, “&gt;”

HINT: If your commands aren’t working to draw anything, try checking the syntax of them first!
Have fun making a masterpiece!</value>
  </data>
</root>